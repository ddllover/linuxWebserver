# 服务器

URL解析：
string？如何避免大量的深拷贝 string_view是否可行 部分使用string_view,特别是const stirng
线程工作分配：
直接竞争一个工作队列/线程负责一部分client

## 两种模型

1. 主线程只负责建立连接，每个子线程相当于一个独立的服务器
2. 主线程负责连接和发配任务，子线程只负责收发：
线程池ThreadPool 是消费者，主线程为生产者  SafeDeque便是生产者消费者模型
线程个数最好为cpu线程数左右，太多会引起锁竞争激烈
由于线程主要时间在执行相互独立的任务，分配和释放锁的资源，比锁竞争耗费更大

3. 主线程负责连接和接受和解析信息，子线程只负责转发

## 逻辑上保证线程安全 / 通过锁同步实现线程安全

* 逻辑上保证线程安全
 epoll本身的函数是线程安全的，但Epoll对象有函数，有写操作就不安全，但并没有多线程操作它
 Socket全是可读的且不可修改的，本身安全
 又比如HttpServe通过epoll来逻辑上实现只有一个线程操作，用写去控制读，读可以多读取几个事件但写由于资源映射的问题
 写不能写的时候会丢失，读只会存在没读完的情况
* 通过锁同步实现线程安全
  比如SafeDeque

## 锁的问题

* 锁颗粒越大，锁竞争越激烈
* 锁颗粒越小，锁本身占用的资源越多，lock_guard 比unique_lock更优

## 并发模型问题，响应有序的问题

模型问题：每个用户有一个httpserve，标志就是套接字，但线程池是忽视这个对象的，只对任务进行操作，通过epoll控制保证操作时候，不会通知新的操作，如此也可以保证处理请求是有序的。
解析一个url请求就回应一个

## vector resize等 会调用构造函数问题  string 也会有

resize缩小和扩大都会调用容器分配器初始化，是会摸除原来的数据

* 利用一个不进行任何初始化的分配器，但相关的操作仍然是O(n)的
* 自己构造一个满足自己最低使用的vector

## 错误处理

assert： 消耗内存非常大，通过DEBUG宏禁用
perror

## ET模式

当读入数据过大时怎么办，或者说如何控制缓存区。

## 读取

* iovec结构体 存储缓冲区ptr和大小
* 高级IO  readv writev 读取数据到多个缓冲区

## 使用mmap()函数实现共享内存，并建立缓冲区减少读取资源的IO操作

先做框架再纠细节,每个用户创建一个HttpServe服务。原框架的一个问题是把接受解析和返回分为两步，分别作为两个任务去派给线程池，但此时已经做了内存映射应该作为一个整体考虑
此外我可以做了两个缓存系统，一个是自己资源的缓存系统，另一个是写入日志的缓存系统

对于传输的数据，分为两个部分，一部分为http响应头，一部分为响应资源.

## stoi 可以使用进制转换

`stoi( const std::string& str, std::size_t* pos = 0, int base = 10 )`
转化直到不符合为止，转化个数存在pos中

## 正则表达式匹配

`std::basic_regex<char> patten("^([^ ]*) ([^ ]*) HTTP/([^ ]*)$")`

* 开头的`^`匹配输入字符开始位置，结尾的`$`匹配结束
* `()`代表一个子表达式可以和smatch匹配,`()?`也是
* `[^...]` 代表`[...]`内内容之外都能匹配
* `.`除换行之外的所有字符
* `?` 0\1个字符 `+` >1个字符  `*` 任意个字符
* 正则表达式是比较浪费时间的

## iterator与const_iterator及const iterator区别

1. iterator,const_iterator作用：遍历容器内的元素，并访问这些元素的值。iterator可以改元素值,但const_iterator不可改。跟C的指针有点像(容器均可以++iter,而vector还可以iter-n, iter+n,n为一整型,iter1-iter2:结果为difference_type类型，表两元素的距离.)
2. const_iterator 对象可以用于const vector 或非 const vector,它自身的值可以改(可以指向其他元素),但不能改写其指向的元素值.
3. const iterator与const_iterator是不一样的：声明一个 const iterator时，必须初始化它。一旦被初始化后，就不能改变它的值,它一旦被初始化后,只能用它来改它指的元素,不能使它指向其他元素。(因此const iterator几乎没什么用途)

## 日志的问题

日志锁，缓冲区

## mysql API

## 编译器优化问题

-O2

## new

* new[0]是合法的，且返回以一个地址，确实占用空间，需要delete[]
* auto 推断问题会忽略&、const 和 volatile

## RAII标准

资源获取即初始化
资源分配（或获取）在对象创建（特别是初始化）期间由构造函数完成，而资源释放（释放）在对象销毁（特别是终结）期间由析构函数完成。

## 错误处理

assert:消耗内存非常大
perror
无阻塞可能存在的特殊的报错EAGAIN，在ET模式下，我们需要读到文件描述符没有数据

## 友好的继承类 simvector

* 把关键变量设为protected而非private
* using 只能改变基类中 public 和 protected 成员的访问权限，不能改变 private 成员的访问权限，因为基类中 private 成员在派生类中是不可见的，根本不能使用，所以基类中的 private 成员在派生类中无论如何都不能访问。

## 如何安全释放一部分connectclient资源

使用map<,int> 利用红黑树对client时间排序，int来标记是否进内存池子
* 做一个进线程池的标记，标记的客户关闭推迟，谁去处理内存池子出的操作，多线程，所以保证线程安全
* 关闭就析构，单个connectclient内存量不大，如果使用内存池？
* 如何安全的关闭底层网络IO，shutdown

## log

文件路径问题 `__FILE__`重新利用编译器定义

## 避免字符串cpoy问题

string_view替换string

## 资源缓存区

* 使用LRU策略
* 关键缓冲区大小问题

## c++迭代器的问题

从c的角度或者从常规变量类型来看，迭代器没有存在的意义。
但是当存在类，对于抽象一层模板对象，我们无法确定操作失败的时候应该返回什么，如果让对方界定
比如map.find()如果找不到，我们怎么让对方知道，没有迭代器是无法做到这点的。
如果我们使用传入指针的方式，或者引用方式，这种方式是不优雅的，这也是c常见一种API
但在c++的里，这种设计思路是被否定的.
