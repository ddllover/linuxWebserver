# 服务器

设计一个服务器类，可能采用单例模式，但打算使用一致性哈希，考虑多个服务器过程。

## 读取

* iovec结构体 存储缓冲区ptr和大小
* 高级IO  readv writev 读取数据到多个缓冲区

## stoi 可以使用进制转换

`stoi( const std::string& str, std::size_t* pos = 0, int base = 10 )`
转化直到不符合为止，转化个数存在pos中

## 正则表达式

`std::basic_regex<char> patten("^([^ ]*) ([^ ]*) HTTP/([^ ]*)$")`

* 开头的`^`匹配输入字符开始位置，结尾的`$`匹配结束
* `()`代表一个子表达式可以和smatch匹配,`()?`也是
* `[^...]` 代表`[...]`内内容之外都能匹配
* `.`除换行之外的所有字符
* `?` 0\1个字符 `+` >1个字符  `*` 任意个字符

## iterator与const_iterator及const iterator区别

1. iterator,const_iterator作用：遍历容器内的元素，并访问这些元素的值。iterator可以改元素值,但const_iterator不可改。跟C的指针有点像(容器均可以++iter,而vector还可以iter-n, iter+n,n为一整型,iter1-iter2:结果为difference_type类型，表两元素的距离.)
2. const_iterator 对象可以用于const vector 或非 const vector,它自身的值可以改(可以指向其他元素),但不能改写其指向的元素值.
3. const iterator与const_iterator是不一样的：声明一个 const iterator时，必须初始化它。一旦被初始化后，就不能改变它的值,它一旦被初始化后,只能用它来改它指的元素,不能使它指向其他元素。(因此const iterator几乎没什么用途)

## string_view 轻量级的string

## 使用mmap()函数实现共享内存，并建立缓冲区减少读取资源的IO操作

先做框架再纠细节,每个用户创建一个HttpServe服务。原框架的一个问题是把接受解析和返回分为两步，分别作为两个任务去派给线程池，但此时已经做了内存映射应该作为一个整体考虑
此外我可以做了两个缓存系统，一个是自己资源的缓存系统，另一个是写入日志的缓存系统

对于传输的数据，分为两个部分，一部分为http响应头，一部分为响应资源.

## 并发模型问题，响应有序的问题

模型问题：每个用户有一个httpserve，标志就是套接字，但线程池是忽视这个对象的，只对任务进行操作，通过epoll控制保证操作时候，不会通知新的操作，如此也可以保证处理请求是有序的。
解析一个url请求就回应一个

## 日志的问题

日志锁，缓冲区

## 计时器的问题

## mysql连接问题

## 锁的问题

* 锁颗粒越大，锁竞争越激烈
* 锁颗粒越小，锁本身占用的资源越多，lock_guard 比unique_lock更优

## 两种模型

1. 主线程只负责建立连接，每个子线程相当于一个独立的服务器
2. 主线程负责连接和发配任务，子线程只负责收发：
线程池ThreadPool 是消费者，主线程为生产者  SafeDeque便是生产者消费者模型
线程个数最好为cpu线程数左右，太多会引起锁竞争激烈
由于线程主要时间在执行相互独立的任务，分配和释放锁的资源，比锁竞争耗费更大

3. 主线程负责连接和接受和解析信息，子线程只负责转发

## 逻辑上保证线程安全 / 通过锁同步实现线程安全

* 逻辑上保证线程安全
 epoll本身的函数是线程安全的，但Epoll对象有函数，有写操作就不安全，但并没有多线程操作它
 Socket全是可读的且不可修改的，本身安全
 又比如HttpServe通过epoll来逻辑上实现只有一个线程操作，用写去控制读，读可以多读取几个事件但写由于资源映射的问题
 写不能写的时候会丢失，读只会存在没读完的情况
* 通过锁同步实现线程安全
  比如SafeDeque

## vector resize等 会调用构造函数问题  string 也会有

resize缩小和扩大都会调用容器分配器初始化，是会摸除原来的数据
* 利用一个不进行任何初始化的分配器，但相关的操作仍然是O(n)的
* 自己构造一个满足自己最低使用的vector

## cmake

## 错误处理

assert： 消耗内存非常大
perror 